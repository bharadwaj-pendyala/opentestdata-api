# TODO

## Big picture

The idea is pretty simple.  Build a database online that is open to people uploading and downloading test data.  For example, test addresses that can be entered into an address field on a web site.  examples of test addresses:
* 1600 Pensylvania Ave
* One Microsoft Way, Redmond, WA
* Bad Address
* Empty string

Today test teams spend a lot of time designing test suites from scratch with data like addresses, names, etc.  It would be far better if there was a shared database of all this data so testers can just download it to use in their manual and automated tests.  Regarding addresses for example...it would be far best if a random app tester didn't make up her own address test cases, but rather got them from a list uploaded by someone at FedEx or UPS that knows all the valid, dangerous, long, invalid, etc. addresses.

Basic requirements in my mind are:
* Ability to upload data via REST API and Web UI
* Ability to download data via REST API and WEB UI
* User accounts required for all upload download
* All data should be tagged, e..g 'positive test', 'negative test', '<scenario name>', etc.
* All data should be searchable and explorable (via tags) visually and via APIs
* System to give points / badges for users that upload valuable data (e.g. others download it and/or up vote it's usefulness)
* Ability to show a profile pic for a given user with their badge
* Ability to flag data for moderation and a quick moderation us for 'admin accounts'. In case someones personal or innappropriate data is uploaded.

## Accounts

* basic user accounts -- collect username, password, email, avatar (stored on google storage)
    * on avatar data upload: convert to jpg, store on google storage using user id as key, set has_avatar to true
    * on signup, send confirmation e-mail with link to confirm

## API endpoints

* User
    * [X] signup
    * [X] confirm email
    * [X] update
    * [X] promote to admin
    * [X] get user data (username, image url (either stored or gravatar))
* Datum
    * [ ] add (verify that no other identical data exists; name doesn't need to be unique but no two identical data+type should exist)
    * [ ] edit? (not sure if this makes sense)
    * [ ] add tag to
    * [ ] remove tag from
    * [ ] find by: tag, name
    * [ ] delete
    * [ ] flag content
* Collection
    * [ ] add (list of datum ids)
    * [ ] update
    * [ ] add tag to
    * [ ] remove tag from
    * [ ] find by: tag, name
    * [ ] delete
    * [ ] flag content


## DB Models

Everything should have created/updated timestamps.

Base models:

* [X] User (username, email, password, has_avatar, is_admin)
* [X] E-mail confirmation tokens (belongs to User) (token)
* [X] Datum - one bit of test data (belongs to User) (name, datum, mode [enum of 'positive', 'negative', 'edge', 'destructive', ...], type [enum of 'string', 'number', 'boolean', 'null'])
* [ ] Tag - string which can be applied to data or collections (belongs to User) (tag, datum_count, collection_count). Tags should be unique, with counts corresponding to how many times they are used?
* [ ] Collection - a container for multiple bits of test data (belongs to User) (name, access_count)
* [ ] Flag - content flag (belongs to User) (type ['inappropriate', ...])

Association tables:

* [ ] tag + datum (datum has many tags)
* [ ] tag + collection (collection has many tags)
* [ ] collection + datum (collection has many data)
* [ ] flag + tag
* [ ] flag + datum
* [ ] flag + collection
