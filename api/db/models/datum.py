from enum import Enum
from .. import db
from .base import BaseModel
from sqlalchemy import exc


class DatumType(Enum):
    NULL = 'NULL'
    BOOLEAN = 'BOOL'
    NUMBER = 'NUM'
    STRING = 'STR'


class DatumMode(Enum):
    NEUTRAL = 'NEUTRAL'
    POSITIVE = 'POS'
    NEGATIVE = 'NEG'
    EDGE = 'EDGE'
    DESTRUCTIVE = 'DESTRUCTIVE'


class Datum(BaseModel):
    __tablename__ = 'data'

    # fields
    name = db.Column(db.String(length=100), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    type = db.Column(db.Enum(DatumType), default=DatumType.STRING, nullable=False)
    mode = db.Column(db.Enum(DatumMode), default=DatumMode.POSITIVE, nullable=False)
    datum = db.Column(db.String(length=1024), nullable=False)

    private_fields = []
    public_fields = ['name', 'type', 'mode', 'datum', 'user_id', 'created_at']

    # relationships
    author = db.relationship('User', back_populates='data', foreign_keys=[user_id])
    # TODO users = db.relationship('User', back_populates='data_used') via join table
    # TODO collections = db.relationship('Collection', back_populates='data') via join table
    # TODO tags many-many via join table

    def __repr__(self):
        return (
            "<Datum '%s' [%s: %s] (by %s)>" %
            (self.name, self.type, self.datum[:20], self.author.username)
        )

    @staticmethod
    def create(*args, **kwargs):
        datum = Datum(**kwargs)
        existing_datum = Datum.query.filter(datum=datum.datum, type=datum.type,
                                            mode=datum.mode).first()
        if existing_datum is not None:
            err = ('The combination of datum, type, and mode must be unique '
                   'and datum with id %s already contains these values' %
                   existing_datum.id)
            raise exc.IntegrityError(err)
        db.session.add(datum)
        db.session.commit()

        return datum
