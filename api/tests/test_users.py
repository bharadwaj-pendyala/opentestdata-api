import pytest
from secrets import token_urlsafe
from werkzeug.security import check_password_hash
from datetime import datetime
from ..db.models import User, Action, ActionType


def test_signup(client, random_username, random_email, random_password):
    cur_time = datetime.now()
    rand_name = random_username()
    resp = client.post('/users', json=dict(
        username=rand_name, email=random_email, password=random_password
    ))
    assert resp['id'] > 0

    # convert the time response and assert that the user was just created
    created_time = datetime.strptime(resp['created_at'], '%Y-%m-%dT%H:%M:%SZ')
    assert (created_time - cur_time).total_seconds() < 5
    assert resp['updated_at'] == resp['created_at']
    assert resp['username'] == rand_name
    assert resp['avatar_url'] != ""
    assert resp['data'] == []

    # assert that certain fields never show up
    assert 'password' not in resp.keys()
    assert 'email' not in resp.keys()
    assert 'password_hash' not in resp.keys()

    # but since we have DB access, actually verify the password was saved
    # correctly, and that no 'password' field exists on the user
    user = User.query.filter_by(id=resp['id']).first()
    assert pytest.raises(AttributeError, lambda: user.password)
    assert check_password_hash(user.password_hash, random_password)
    assert user.email == random_email
    assert user.ec_token != ""
    assert user.is_email_confirmed is False
    assert user.is_admin is False

    # verify action was added
    action = Action.query.filter_by(type=ActionType.SIGNUP, user_id=user.id).first()
    assert action is not None

    # user can not sign up twice
    resp = client.post('/users', raw=True, json=dict(
        username=rand_name, email=random_email, password=random_password
    )).get_json()
    assert resp['status'] == 400
    assert 'exists' in resp['detail']


def test_cant_signup_with_existing_username(client, user, random_email, random_password):
    resp = client.post('/users', raw=True, json=dict(
        username=user.username,
        email=random_email,
        password=random_password
    )).get_json()
    assert resp['status'] == 400
    assert 'already exists' in resp['detail']


def test_cant_signup_with_existing_email(client, user, random_username, random_password):
    resp = client.post('/users', raw=True, json=dict(
        username=random_username(),
        email=user.email,
        password=random_password
    )).get_json()
    assert resp['status'] == 400
    assert 'already exists' in resp['detail']


def test_signup_missing_fields(client, random_username, random_email):
    resp = client.post('/users', raw=True, json=dict()).get_json()
    assert resp['status'] == 400
    assert 'username' in resp['detail']

    resp = client.post('/users', raw=True, json=dict(
        username=random_username()
    )).get_json()
    assert resp['status'] == 400
    assert 'email' in resp['detail']

    resp = client.post('/users', raw=True, json=dict(
        username=random_username(), email=random_email
    )).get_json()
    assert resp['status'] == 400
    assert 'password' in resp['detail']


def test_signup_long_username(client, random_email, random_password):
    username = token_urlsafe(100)
    resp = client.post('/users', raw=True, json=dict(
        username=username, email=random_email, password=random_password
    )).get_json()
    assert resp['status'] == 400
    assert 'too long' in resp['detail']


@pytest.mark.skip(reason="TODO")
def test_signup_sql_injection_attack(client):
    pass


def test_user_detail(client, user):
    resp = client.get('/users/%s' % user.id, headers=user.auth_headers)

    assert 'password' not in resp.keys()
    assert 'email' not in resp.keys()
    assert 'password_hash' not in resp.keys()

    assert resp['id'] == user.id
    assert resp['username'] == user.username


def test_user_confirm_email(client, user):
    assert user.is_email_confirmed is False
    resp = client.get('/users/confirm_email/%s' % user.ec_token.token)
    assert resp['confirmed']
    assert user.is_email_confirmed is True
    assert user.ec_token is None


def test_user_confirm_email_fails_bad_token(client, user):
    assert user.is_email_confirmed is False
    resp = client.get('/users/confirm_email/%s' % 'foobar', raw=True).get_json()
    assert resp['status'] == 404
    assert 'token' in resp['detail']
    assert user.is_email_confirmed is False
    assert user.ec_token.token is not None


def test_user_can_update_details(client, user):
    new_email = 'foo@foo.com'
    new_password = 'foobarbaz'

    user.is_email_confirmed = True
    assert user.email != new_email
    assert user.check_password(new_password) is False

    client.post('/users/%s' % user.id, headers=user.auth_headers, json=dict(
        email=new_email, password=new_password
    ))

    user = User.query.filter_by(id=user.id).first()
    assert user.email == new_email
    assert user.is_email_confirmed is False
    assert user.check_password(new_password)


def test_user_cannot_update_details_for_other_user(client, user, other_user):
    new_email = 'foo@foo.com'
    new_password = 'foobarbaz'

    user.is_email_confirmed = True

    resp = client.post('/users/%s' % other_user.id, headers=user.auth_headers, raw=True, json=dict(
        email=new_email, password=new_password
    )).get_json()

    assert resp['status'] == 401
    assert 'permission' in resp['detail']

    other_user = User.query.filter_by(id=other_user.id).first()
    assert user.email != new_email
    assert not user.check_password(new_password)


@pytest.mark.skip(reason="TODO")
def test_user_can_update_other_user_if_admin():
    pass


@pytest.mark.skip(reason="TODO")
def test_user_can_update_one_field_at_a_time():
    pass


@pytest.mark.skip(reason="TODO")
def test_user_cant_update_certain_fields():
    # TODO like username etc
    pass


def test_admin_can_promote_user(client, user, admin_user):
    assert not user.is_admin
    client.post('/users/%s/promote' % user.id, headers=admin_user.auth_headers)
    assert User.query.filter_by(id=user.id).first().is_admin


def test_non_admin_cant_promote_user(client, user, other_user):
    assert not user.is_admin
    resp = client.post('/users/%s/promote' % user.id, headers=other_user.auth_headers, raw=True).get_json()
    assert resp['status'] == 401
    assert 'admin' in resp['detail']
    assert not User.query.filter_by(id=user.id).first().is_admin


def test_user_cant_promote_self(client, user):
    assert not user.is_admin
    resp = client.post('/users/%s/promote' % user.id, headers=user.auth_headers, raw=True).get_json()
    assert resp['status'] == 401
    assert 'admin' in resp['detail']
    assert not User.query.filter_by(id=user.id).first().is_admin
